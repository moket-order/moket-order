/*
통합 주문 관리 스크립트 (GAS) - v49.3 (스타일 통합 및 구문 최적화)
- [스타일] 이미지처럼 입고/픽업/현판/취소 시 행 전체 색상 및 취소선 자동 적용
- [기능] 상품명 줄바꿈 대응 및 실시간 고객 DB 업데이트 포함
*/

const ROOT_NAME = "주문서";
const SUB_ROOT_NAME = "주문내역";
const IMAGE_ROOT_NAME = "상품이미지";
const TEMPLATE_NAME = "[템플릿] 주문내역";

// [1] 메뉴 및 사이드바
function onOpen() {
SpreadsheetApp.getUi()
.createMenu('모켓 메뉴')
.addItem('주문 알림창 열기', 'showSidebar')
.addItem('이미지 ID 전체 갱신', 'updateMissingImageIds')
.addItem('고객 데이터베이스 전체 갱신', 'syncAllCustomersToDB')
.addToUi();
}

function showSidebar() {
const html = HtmlService.createHtmlOutputFromFile('Sidebar').setTitle('주문 알림 대기중').setWidth(300);
SpreadsheetApp.getUi().showSidebar(html);
}

// [2] 유틸리티 함수
function getLatestOrderTime() {
return PropertiesService.getScriptProperties().getProperty("LATEST_ORDER_TIME") || "0";
}

function getCachedFolderId(parentId, folderName) {
const props = PropertiesService.getScriptProperties();
const key = "FLD_ID_" + (parentId || "ROOT") + "_" + folderName;
let id = props.getProperty(key);
if (id) {
try { DriveApp.getFolderById(id); return id; } catch (e) { props.deleteProperty(key); }
}
const parent = parentId ? DriveApp.getFolderById(parentId) : DriveApp.getRootFolder();
const folders = parent.getFoldersByName(folderName);
if (folders.hasNext()) {
const folder = folders.next();
id = folder.getId();
props.setProperty(key, id);
return id;
}
const newFolder = parent.createFolder(folderName);
id = newFolder.getId();
props.setProperty(key, id);
return id;
}

function makeRes(o) {
return ContentService.createTextOutput(JSON.stringify(o)).setMimeType(ContentService.MimeType.JSON);
}

function normD(v) { return String(v || "").replace(/\D/g, ""); }

function normP(p) {
let s = String(p || "").replace(/\D/g, "");
if ((s.length === 10 || s.length === 11) && !s.startsWith("0")) return "0" + s;
return s;
}

function cleanNP(n) {
return String(n || "").replace(/[\r\n]+/g, " ").replace(/\s+/g, " ").trim();
}

function getKRDay(d) {
const days = ["일", "월", "화", "수", "목", "금", "토"];
return days[d.getDay()];
}

function formatDateTime(d) {
return Utilities.formatDate(d, "GMT+9", "yy년 M월 d일") + " (" + getKRDay(d) + ")\n" + Utilities.formatDate(d, "GMT+9",
"HH:mm:ss");
}

function formatKRDate(s) {
const d = (s instanceof Date) ? s : new Date(s);
return Utilities.formatDate(d, "GMT+9", "yy년 M월 d일") + " (" + getKRDay(d) + ")";
}

// [3] API 라우팅
function doGet(e) {
try {
const action = e.parameter.action;
if (action === "ping") return makeRes({ result: "pong" });
if (action === "fetchProductImages") return fetchProductImages(e.parameter.name, e.parameter.folderId);
if (action === "fetchOrderHistory" || e.parameter.header === "history") {
return fetchHistory(e.parameter.name, e.parameter.phone, e.parameter.scope);
}
if (action === "getLatestOrderTime" || e.parameter.header === "getLatestOrderTime") {
return makeRes({ result: "success", time: getLatestOrderTime() });
}
return fetchProducts();
} catch (err) {
return makeRes({ result: "error", message: err.toString() });
}
}

function doPost(e) {
const lock = LockService.getScriptLock();
try {
if (!lock.tryLock(10000)) return makeRes({ result: "error", message: "서버가 혼잡합니다." });
const data = JSON.parse(e.postData.contents);
if (data.header === "order") {
const resp = processOrder(data);
if (resp && JSON.parse(resp.getContent()).result === "success") {
updateCustomerDatabase(data.phone, data.name);
}
return resp;
}
if (data.header === "delete") return handleDelete(data);
return makeRes({ result: "success" });
} catch (err) {
return makeRes({ result: "error", message: err.toString() });
} finally {
lock.releaseLock();
}
}

// [4] 자동화 트리거 (onEdit 스타일 적용)
function onEdit(e) {
if (!e) return;
const range = e.range;
const sh = range.getSheet();
const sName = sh.getName();
if (range.getRow() < 2) return; const lastCol=sh.getLastColumn(); if (lastCol===0) return; const headers=sh.getRange(1,
  1, 1, lastCol).getValues()[0].map(h=> String(h).trim());

  if (sName.includes("상품") && !sName.includes("주문내역")) {
  const pNameCol = headers.findIndex(h => h.includes("상품명") || h.includes("품명")) + 1;
  const folderIdCol = headers.findIndex(h => h.includes("이미지폴더ID")) + 1;
  const imageIdCol = headers.findIndex(h => h.includes("이미지ID") || h.includes("이미지주소")) + 1;

  if (pNameCol > 0 && range.getColumn() === pNameCol) {
  const pName = cleanNP(e.value);
  if (pName) {
  try {
  const imgRoot = DriveApp.getFolderById(getCachedFolderId(getCachedFolderId(null, ROOT_NAME), IMAGE_ROOT_NAME));
  const folders = imgRoot.getFoldersByName(pName);
  let folder = folders.hasNext() ? folders.next() : imgRoot.createFolder(pName);
  if (folderIdCol > 0) sh.getRange(range.getRow(), folderIdCol).setValue(folder.getId());
  if (imageIdCol > 0) {
  const files = folder.getFiles();
  if (files.hasNext()) sh.getRange(range.getRow(), imageIdCol).setValue(files.next().getId());
  }
  } catch (err) { console.error("onEdit error", err); }
  }
  }
  }

  // 주문내역 시트 실시간 스타일 및 DB 업데이트
  if (sName.includes("주문내역")) {
  const cancelCol = headers.findIndex(h => h.includes("주문취소")) + 1;
  const pickupCol = headers.findIndex(h => h.includes("픽업여부")) + 1;
  const onsiteCol = headers.findIndex(h => h.includes("현장판매")) + 1;

  // 체크박스 변경 시 고객 DB 실시간 업데이트
  if (range.getColumn() === cancelCol || range.getColumn() === pickupCol || range.getColumn() === onsiteCol) {
  const rowData = sh.getRange(range.getRow(), 1, 1, headers.length).getValues()[0];
  const name = String(rowData[2]).trim();
  const phone = String(rowData[3]).trim();
  if (name && phone) updateCustomerDatabase(phone, name);
  }
  }
  }

  // [5] 주문 처리 (이미지 스타일 및 조건부 서식 포함)
  function processOrder(data) {
  const { name, phone, items, timestamp } = data;
  const ssMain = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ssMain.getSheets().find(s => s.getName().includes("상품")) || ssMain.getSheets()[0];
  const pData = sheet.getDataRange().getValues();
  const h = pData[0].map(x => String(x).trim());
  const sIdx = h.findIndex(x => x.includes("재고") || x.includes("수량"));

  for (const it of items) {
  const rid = findRowIndex(pData, it.name, it.date, h);
  if (rid && sIdx !== -1 && (Number(pData[rid - 1][sIdx]) || 0) < Number(it.qty)) { return makeRes({ result: "error" ,
    message: "재고부족: " + it.name }); } } items.forEach(it=> {
    const rid = findRowIndex(pData, it.name, it.date, h);
    if (rid && sIdx !== -1) {
    const next = (Number(pData[rid - 1][sIdx]) || 0) - Number(it.qty);
    sheet.getRange(rid, sIdx + 1).setValue(next);
    it.remainingStock = next;
    }
    });

    PropertiesService.getScriptProperties().setProperty("LATEST_ORDER_TIME", String(new Date().getTime()));
    const subRootId = getCachedFolderId(getCachedFolderId(null, ROOT_NAME), SUB_ROOT_NAME);
    const groups = items.reduce((acc, it) => {
    const d = it.date || Utilities.formatDate(new Date(), "GMT+9", "yyyy-MM-dd");
    if (!acc[d]) acc[d] = [];
    acc[d].push(it);
    return acc;
    }, {});

    for (const date in groups) {
    const [y, m, d] = date.split("-");
    const yf = DriveApp.getFolderById(getCachedFolderId(subRootId, y + "년"));
    const fName = `${y}년 ${m}월 주문내역`;
    let oss = getSS(yf, fName);
    if (!oss) {
    const tmpl = DriveApp.getFilesByName(TEMPLATE_NAME);
    oss = tmpl.hasNext() ? SpreadsheetApp.open(tmpl.next().makeCopy(fName, yf)) : SpreadsheetApp.create(fName);
    if (!tmpl.hasNext()) DriveApp.getFileById(oss.getId()).moveTo(yf);
    }
    const tName = `${parseInt(m)}월 ${parseInt(d)}일`;
    let tsh = oss.getSheetByName(tName) || oss.insertSheet(tName);

    if (tsh.getLastRow() === 0) {
    const head = ["주문시간", "픽업일", "주문자명", "연락처", "카톡 이름", "카톡 연락처", "주문내역", "수량", "가격", "합계", "알림메시지", "입고여부", "픽업여부",
    "현장판매", "주문취소"];
    tsh.appendRow(head);
    tsh.getRange(1, 1, 1,
    head.length).setBackground("#4CAF50").setFontColor("white").setFontWeight("bold").setHorizontalAlignment("center").setVerticalAlignment("middle");
    tsh.setFrozenRows(1);

    // 열 너비 설정 (이미지 스타일 복구)
    tsh.setColumnWidth(1, 150); // 주문시간
    tsh.setColumnWidth(7, 180); // 주문내역
    tsh.setColumnWidth(11, 250); // 알림메시지
    tsh.setColumnWidths(12, 4, 70); // 체크박스들

    // 조건부 서식 설정 (이미지 스타일 복구)
    const lastRowRange = 2000;
    const rules = [];
    // 주문취소 (O열)
    rules.push(SpreadsheetApp.newConditionalFormatRule().whenFormulaSatisfied("=$O2=TRUE").setStrikethrough(true).setFontColor("#999999").setBackground("#efefef").setRanges([tsh.getRange("A2:O"
    + lastRowRange)]).build());
    // 입고여부 (L열)
    rules.push(SpreadsheetApp.newConditionalFormatRule().whenFormulaSatisfied("=$L2=TRUE").setBackground("#ffe599").setRanges([tsh.getRange("L2:L"
    + lastRowRange)]).build());
    // 픽업여부 (M열)
    rules.push(SpreadsheetApp.newConditionalFormatRule().whenFormulaSatisfied("=$M2=TRUE").setBackground("#b7e1cd").setRanges([tsh.getRange("M2:M"
    + lastRowRange)]).build());
    // 현장판매 (N열)
    rules.push(SpreadsheetApp.newConditionalFormatRule().whenFormulaSatisfied("=$N2=TRUE").setBackground("#f9cb9c").setRanges([tsh.getRange("N2:N"
    + lastRowRange)]).build());
    tsh.setConditionalFormatRules(rules);
    }

    groups[date].forEach(it => {
    const lastRow = tsh.getLastRow() + 1;
    const od = new Date(timestamp);
    const timeStr = Utilities.formatDate(od, "GMT+9", "yy년 MM월 dd일") + " (" + getKRDay(od) + ") " +
    Utilities.formatDate(od, "GMT+9", "HH시 mm분");
    const orderMsg = timeStr + "\n" + name + "님,\n" + it.name + " " + it.qty + "개 주문 완료!\n남은수량은 " + it.remainingStock +
    "개 입니다.";
    const rData = [formatDateTime(od), formatKRDate(date), name, "'" + phone, data.kakaoName || "비인증", data.kakaoPhone ?
    ("'" + data.kakaoPhone) : "비인증", it.name, it.qty, it.price, it.price * it.qty, orderMsg];
    tsh.appendRow(rData);

    const rowRange = tsh.getRange(lastRow, 1, 1, 15);
    rowRange.setVerticalAlignment("middle");

    const orangeStyle = SpreadsheetApp.newTextStyle().setForegroundColor("#f68b1e").setBold(true).build();
    let rb = SpreadsheetApp.newRichTextValue().setText(orderMsg);
    const nameStart = orderMsg.indexOf(name);
    if (nameStart !== -1) rb.setTextStyle(nameStart, nameStart + name.length, orangeStyle);
    const qtyStr = String(it.qty);
    const qtyIdx = orderMsg.indexOf(" " + qtyStr + "개", nameStart + name.length) + 1;
    if (qtyIdx > 0) rb.setTextStyle(qtyIdx, qtyIdx + qtyStr.length, orangeStyle);

    tsh.getRange(lastRow, 1, 1, 7).setHorizontalAlignment("left");
    tsh.getRange(lastRow, 8).setHorizontalAlignment("center");
    tsh.getRange(lastRow, 9, 1, 2).setHorizontalAlignment("right").setNumberFormat("#,##0");
    tsh.getRange(lastRow, 11).setRichTextValue(rb.build()).setWrap(true).setHorizontalAlignment("left");
    tsh.getRange(lastRow, 12, 1, 4).insertCheckboxes().setHorizontalAlignment("center").setValue(false);
    });
    }
    return makeRes({ result: "success" });
    }

    // 나머지 함수들 (findRowIndex, handleDelete, fetchProducts, syncAllCustomersToDB 등 v49.3 기준 유지)
    function findRowIndex(pData, name, date, headers) {
    const nIdx = headers.findIndex(x => x.includes("상품명") || x.includes("품명"));
    const dIdx = headers.findIndex(x => x.includes("날짜") || x.includes("픽업"));
    const targetName = cleanNP(name);
    for (let i = 1; i < pData.length; i++) { let rD=pData[i][dIdx]; rD=(rD instanceof Date) ?
      Utilities.formatDate(rD, "GMT+9" , "yyyy-MM-dd" ) : String(rD).trim(); if (cleanNP(pData[i][nIdx])===targetName &&
      rD===date) return i + 1; } return null; } function handleDelete(data) { const { name, timestamp, item }=data;
      const tD=normD(timestamp); const targetItem=String(item || "" ).replace(/\[취소\]/g, "" ).replace(/['"]/g, ''
      ).trim(); const rootId=getCachedFolderId(null, ROOT_NAME); const subRootId=getCachedFolderId(rootId,
      SUB_ROOT_NAME); const subRoot=DriveApp.getFolderById(subRootId); const years=subRoot.getFolders(); while
      (years.hasNext()) { const yf=years.next(); const fs=yf.getFiles(); while (fs.hasNext()) { const f=fs.next(); if
      (!f.getName().includes("주문내역")) continue; try { const ss=SpreadsheetApp.open(f); const sheets=ss.getSheets(); for
      (let sh of sheets) { const rows=sh.getDataRange().getValues(); for (let i=1; i < rows.length; i++) { const
      rowDigitTime=normD(rows[i][0]); const isTimeMatch=(rowDigitTime===tD) || (rowDigitTime.length> tD.length ?
      rowDigitTime.endsWith(tD) : tD.endsWith(rowDigitTime));
      const sheetItem = String(rows[i][6] || "").replace(/\[취소\]/g, "").replace(/['"]/g, "").trim();
      if (isTimeMatch && String(rows[i][2]).trim() === name && sheetItem === targetItem) {
      if (rows[i][14] === true || String(rows[i][6]).includes("[취소]")) return makeRes({ result: "success" });
      const qty = Number(rows[i][7]) || 0;
      const pDateStr = String(rows[i][1]).trim();
      sh.getRange(i + 1, 7).setValue("[취소] " + rows[i][6]);
      sh.getRange(i + 1, 15).setValue(true);
      try {
      const ssMain = SpreadsheetApp.getActiveSpreadsheet();
      const pSheet = ssMain.getSheets().find(s => s.getName().includes("상품")) || ssMain.getSheets()[0];
      const pData = pSheet.getDataRange().getValues();
      const pHeaders = pData[0].map(h => String(h).trim());
      let mDate = "";
      const dm = pDateStr.match(/(\d{2})년\s*(\d{1,2})월\s*(\d{1,2})일/);
      if (dm) mDate = "20" + dm[1] + "-" + dm[2].padStart(2, '0') + "-" + dm[3].padStart(2, '0');
      const pRow = findRowIndex(pData, rows[i][6], mDate, pHeaders);
      if (pRow) {
      const sCol = pHeaders.findIndex(h => h.includes("재고") || h.includes("수량")) + 1;
      if (sCol > 0) pSheet.getRange(pRow, sCol).setValue((Number(pSheet.getRange(pRow, sCol).getValue()) || 0) + qty);
      }
      } catch (e) {}
      updateCustomerDatabase(rows[i][3], name);
      SpreadsheetApp.flush();
      return makeRes({ result: "success" });
      }
      }
      }
      } catch (e) {}
      }
      }
      return makeRes({ result: "error", message: "주문 미찾음" });
      }

      function fetchProducts() { const ss=SpreadsheetApp.getActiveSpreadsheet(); const
      sheet=ss.getSheets().find(s=> s.getName().includes("상품")) || ss.getSheets()[0];
      const data = sheet.getDataRange().getValues();
      if (data.length < 2) return makeRes([]); const headers=data[0].map(h=> String(h).trim().replace(/\s/g, ""));
        const products = data.slice(1).map(row => {
        let raw = {};
        headers.forEach((h, i) => { raw[h] = row[i]; });
        const pName = cleanNP(raw["상품명"] || raw["품명"] || "");
        if (!pName) return null;
        const p = {
        name: pName, price: Number(raw["가격"] || raw["단가"] || 0), stock: raw["재고"] || raw["수량"] || 0,
        desc: raw["설명"] || raw["상세"] || "", date: "", matchKey: "", images: [], folderId: String(raw["이미지폴더ID"] ||
        "").trim()
        };
        let dVal = raw["날짜"] || raw["픽업"] || raw["픽업일"] || raw["판매일"] || raw["일자"] || "";
        if (dVal instanceof Date) { p.date = Utilities.formatDate(dVal, "GMT+9", "yyyy-MM-dd"); }
        else {
        const cleanedDate = String(dVal).replace(/\./g, "-").replace(/\s+/g, "").trim();
        const match = cleanedDate.match(/^(\d{4})-(\d{1,2})-(\d{1,2})$/);
        p.date = match ? `${match[1]}-${match[2].padStart(2, '0')}-${match[3].padStart(2, '0')}` : String(dVal).trim();
        }
        p.matchKey = p.date;
        const idVal = String(raw["이미지ID"] || raw["이미지주소"] || "").trim();
        if (idVal) { p.images = [idVal.split(",")[0].trim()]; }
        else if (p.folderId) {
        try {
        const folder = DriveApp.getFolderById(p.folderId);
        const files = folder.getFiles();
        const fileList = [];
        while (files.hasNext()) { const f = files.next(); if (f.getMimeType().startsWith("image/")) fileList.push(f); }
        if (fileList.length > 0) {
        fileList.sort((a, b) => a.getName().localeCompare(b.getName(), undefined, { numeric: true, sensitivity: 'base'
        }));
        p.images = [fileList[0].getId()];
        }
        } catch (e) { }
        }
        return p;
        }).filter(p => p !== null);
        return makeRes(products);
        }

        function getSS(f, n) {
        const fs = f.getFilesByName(n);
        return fs.hasNext() ? SpreadsheetApp.open(fs.next()) : null;
        }

        function updateMissingImageIds() {
        const ss = SpreadsheetApp.getActiveSpreadsheet();
        const sheet = ss.getSheets().find(s => s.getName().includes("상품")) || ss.getSheets()[0];
        const data = sheet.getDataRange().getValues();
        const headers = data[0].map(h => String(h).trim().replace(/\s/g, ""));
        const pCol = headers.findIndex(h => h.includes("상품명") || h.includes("품명"));
        const fCol = headers.findIndex(h => h.includes("이미지폴더ID"));
        const iCol = headers.findIndex(h => h.includes("이미지ID") || h.includes("이미지주소"));
        if (pCol === -1 || fCol === -1 || iCol === -1) return;
        const imgRoot = DriveApp.getFolderById(getCachedFolderId(getCachedFolderId(null, ROOT_NAME), IMAGE_ROOT_NAME));
        for (let i = 1; i < data.length; i++) { const name=cleanNP(data[i][pCol]); if (!name) continue; let
          folderId=String(data[i][fCol]).trim(); let folder; if (!folderId) { const
          folders=imgRoot.getFoldersByName(name); if (folders.hasNext()) { folder=folders.next();
          folderId=folder.getId(); sheet.getRange(i + 1, fCol + 1).setValue(folderId); } } else { try {
          folder=DriveApp.getFolderById(folderId); } catch (e) { } } if (folder && !String(data[i][iCol]).trim()) {
          const files=folder.getFiles(); const fileList=[]; while (files.hasNext()) { const f=files.next(); if
          (f.getMimeType().startsWith("image/")) fileList.push(f); } if (fileList.length> 0) {
          fileList.sort((a, b) => a.getName().localeCompare(b.getName(), undefined, { numeric: true, sensitivity: 'base'
          }));
          sheet.getRange(i + 1, iCol + 1).setValue(fileList[0].getId());
          }
          }
          }
          }

          function fetchProductImages(name, folderId) {
          try {
          const targetName = cleanNP(name);
          let folder;
          if (folderId && folderId !== "undefined" && folderId !== "") { try { folder =
          DriveApp.getFolderById(folderId); } catch (e) { } }
          if (!folder) {
          const imgRoot = DriveApp.getFolderById(getCachedFolderId(getCachedFolderId(null, ROOT_NAME),
          IMAGE_ROOT_NAME));
          const folders = imgRoot.getFoldersByName(targetName);
          if (folders.hasNext()) folder = folders.next();
          }
          if (!folder) return makeRes([]);
          const files = folder.getFiles();
          const fileList = [];
          while (files.hasNext()) { const f = files.next(); if (f.getMimeType().startsWith("image/")) fileList.push(f);
          }
          fileList.sort((a, b) => a.getName().localeCompare(b.getName(), undefined, { numeric: true, sensitivity: 'base'
          }));
          return makeRes(fileList.map(f => f.getId()));
          } catch (e) { return makeRes([]); }
          }

          function syncAllCustomersToDB() {
          const ui = SpreadsheetApp.getUi();
          const subRoot = DriveApp.getFolderById(getCachedFolderId(getCachedFolderId(null, ROOT_NAME), SUB_ROOT_NAME));
          const customers = {};
          const years = subRoot.getFolders();
          while (years.hasNext()) {
          const yf = years.next();
          const fs = yf.getFiles();
          while (fs.hasNext()) {
          const f = fs.next();
          if (!f.getName().includes("주문내역")) continue;
          try {
          const ss = SpreadsheetApp.open(f);
          ss.getSheets().forEach(sh => {
          const rows = sh.getDataRange().getValues();
          for (let i = 1; i < rows.length; i++) { const p=normP(rows[i][3]); if (p)
            customers[p]=String(rows[i][2]).trim(); } }); } catch (e) { } } } Object.keys(customers).forEach(p=>
            updateCustomerDatabase(p, customers[p]));
            ui.alert("완료!");
            }

            function updateCustomerDatabase(phone, name) {
            const targetP = normP(phone);
            if (!targetP) return;
            let history = getAllHistoryForCustomer(name, targetP);
            if (history.length === 0) return;
            history.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            const latestKakao = history.find(h => h.kakaoName && h.kakaoName !== "비인증") || history[0];
            const stats = calculateStats(history);
            if (stats) writeToCustomerDatabase(name, targetP, stats, latestKakao.kakaoName, latestKakao.kakaoPhone);
            }

            function getAllHistoryForCustomer(name, phone) {
            const result = [];
            const subRoot = DriveApp.getFolderById(getCachedFolderId(getCachedFolderId(null, ROOT_NAME),
            SUB_ROOT_NAME));
            const years = subRoot.getFolders();
            while (years.hasNext()) {
            const yf = years.next();
            const fs = yf.getFiles();
            while (fs.hasNext()) {
            const f = fs.next();
            if (!f.getName().includes("주문내역")) continue;
            try {
            const ss = SpreadsheetApp.open(f);
            ss.getSheets().forEach(sh => {
            const data = sh.getDataRange().getValues();
            for (let i = 1; i < data.length; i++) { if (normP(data[i][3])===phone) { result.push({ timestamp:
              data[i][0], item: data[i][6], qty: Number(data[i][7]) || 0, price: Number(data[i][8]) || 0, total:
              Number(data[i][9]) || 0, received: data[i][12]===true, onSite: data[i][13]===true, canceled:
              data[i][14]===true || String(data[i][6]).includes("[취소]"), kakaoName: data[i][4], kakaoPhone: data[i][5]
              }); } } }); } catch (e) { } } } return result; } function calculateStats(history) { const
              total=history.length; if (total===0) return null; const active=history.filter(h=> !h.canceled);
              const cancelled = history.filter(h => h.canceled);
              const pickedUp = active.filter(h => h.received);
              const onSite = active.filter(h => h.onSite);
              const totalSpend = active.reduce((sum, h) => sum + h.total, 0);
              let latestDate = new Date(0);
              history.forEach(h => {
              let d = h.timestamp instanceof Date ? h.timestamp : new Date(h.timestamp);
              if (d > latestDate) latestDate = d;
              });
              return {
              latest: formatKRDate(latestDate), totalCount: total, pickupCount: pickedUp.length, onSiteCount:
              onSite.length, cancelCount: cancelled.length,
              cancelRate: total > 0 ? (cancelled.length / total) : 0, spending: totalSpend
              };
              }

              function writeToCustomerDatabase(name, phone, stats, kName, kPhone) {
              const rootId = getCachedFolderId(null, ROOT_NAME);
              const fileName = "고객 데이터베이스";
              const folders = DriveApp.getFolderById(rootId).getFilesByName(fileName);
              let ss = folders.hasNext() ? SpreadsheetApp.open(folders.next()) : SpreadsheetApp.create(fileName);
              if (ss.getSheets()[0].getLastRow() === 0) {
              ss.getSheets()[0].appendRow(["고객명", "연락처", "카톡 이름", "카톡 연락처", "최근 주문일", "총 주문건수", "총 픽업완료건수", "총 현장판매건수",
              "총 주문취소건수", "취소율", "누적 주문금액"]);
              DriveApp.getFileById(ss.getId()).moveTo(DriveApp.getFolderById(rootId));
              }
              const sheet = ss.getSheets()[0];
              const data = sheet.getDataRange().getValues();
              let rowIdx = -1;
              for (let i = 1; i < data.length; i++) { if (normP(data[i][1])===phone) { rowIdx=i + 1; break; } } const
                rowData=[name, "'" + phone, kName || "비인증" , kPhone || "비인증" , stats.latest, stats.totalCount,
                stats.pickupCount, stats.onSiteCount, stats.cancelCount, stats.cancelRate, stats.spending]; if (rowIdx>
                -1) sheet.getRange(rowIdx, 1, 1, rowData.length).setValues([rowData]);
                else sheet.appendRow(rowData);
                }

                function scanSheet(sh, targetName, targetPhone, resultArr) {
                try {
                const data = sh.getDataRange().getValues();
                for (let i = 1; i < data.length; i++) { if (normP(data[i][3])===targetPhone &&
                  String(data[i][2]).trim()===targetName) { resultArr.push({ timestamp: data[i][0], pickupDate:
                  data[i][1], name: data[i][2], item: data[i][6], qty: data[i][7], price: data[i][8], total: data[i][9],
                  isStocked: data[i][11], received: data[i][12], onSite: data[i][13], canceled: data[i][14] }); } } }
                  catch (e) { } } function fetchHistory(name, phone, scope) { const targetP=normP(phone), targetN=(name
                  || "" ).trim(); const result=[]; const
                  subRoot=DriveApp.getFolderById(getCachedFolderId(getCachedFolderId(null, ROOT_NAME), SUB_ROOT_NAME));
                  const years=subRoot.getFolders(); while (years.hasNext()) { const yf=years.next(); const
                  fs=yf.getFiles(); while (fs.hasNext()) { const f=fs.next(); if (!f.getName().includes("주문내역"))
                  continue; try { const ss=SpreadsheetApp.open(f); ss.getSheets().forEach(sh=> scanSheet(sh, targetN,
                  targetP, result));
                  } catch (e) { }
                  }
                  }
                  return makeRes(result.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp)));
                  }
